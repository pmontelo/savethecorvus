 sbtl  "CORVUS ProROM by Patrick Montelo"************************                     **  ProROM for CORVUS  **  DOS 3.3 & ProDOS   **                     ** Copyright 1984-2025 **   Patrick Montelo   **                     **       Thanks        **   Curt Rostenbach   **                     ************************ msb off** Equates*cfgMask equ $A5dosTracks equ 50dosSects equ 16stack equ $100keyVol equ $AA66** Character Codes*chrCR equ $0D************************************************************************** DOS 3.3 IOB data structure************************************************************************ dsect org $0iobType db 0iobSlot db 0iobDrive db 0iobVol db 0iobTrack db 0iobSector db 0iobDCT dw $0000iobBuffer dw $0000iobUnused db 0iobPart db 0iobCommand db 0iobStatus db 0iobLastVol db 0iobLastSlot db 0iobLastDrive db 0 dend** IOB commands*cmdSeek equ 0cmdRead equ 1cmdWrite equ 2cmdFormat equ 3** IOB statuses*sSuccess equ $0sWriteProt equ $10sVolMismat equ $20sDriveErr equ $40sReadErr equ $80** DOS Zero Page*zpIOB equ $48tempPtr equ $4E ; Temporary pointer used in RWTS code** DOS Calling vectors*dvRWTS equ $3D9************************************************************************** ProDOS commands************************************************************************pcmdStatus equ $0pcmdRead equ $1pcmdWrite equ $2pcmdFormat equ $3** ProDOS A register return codes*pdSuccess equ 0pdIoErr equ $27pdNoDevCon equ $28pdWriteProt equ $2B** ProDOS ROM code calling conventions (Tech Ref 6.3.1)* Call Parameters (6.3.2)*pdCommand equ $42pdUnitNum equ $43pdBuffer equ $44pdBlock equ $46 ; pdBlock is converted to sectors in calcSect** DOS 3.3 screen holes - slot 0 usage*;drv1Trk equ $478;drv2Trk equ $4F8;seekCnt equ $4F8;retryCnt equ $578;slot equ $5F8 ; Same as ioOffset;slotAbs equ $678;recalCnt equ $6F8** ProROM screen holes - slot 0 usage*ioOffset equ $5F8 ; Card slot IO offset = slot x $10pdBufferL equ $678 ; Backup of pdBuffer $44-45pdBufferH equ $6F8 ; Backup of pdBuffer+1pdBlockL equ $578 ; Backup of pdBlock $46-47pdBlockH equ $778 ; Backup of pdBlock+1*slot equ $4F8 ; testing slot 1-7cSlot equ $7F8 ; testing slot $C1-$C7** Text screen holes - config state stored at base address + slot number*blocksD1L equ $478 ; Total blocks drive 1 LSB, NUMBLCKL0 EQU $478blocksD1H equ $4F8 ; Total blocks drive 1 MSB, NUMBLCKH0 EQU $4F8blocksD2L equ $578 ; Total blocks drive 2 LSB, NUMBLCKL1 EQU $578blocksD2H equ $5F8 ; Total blocks drive 2 MSB, NUMBLCKH1 EQU $5F8cfgVolsD1 equ $678 ;$6F8 ; Number of DOS volumes D1, *NUMVOL0 EQU $678cfgVolsD2 equ $6F8 ;$778 ; Number of DOS volumes D2, *NUMVOL1 EQU $6F8cfgChkSum equ $778 ;$7F8 ; Check sum of config block eor cfgMask, *PARMSUM EQU $778cfgDrive equ $7F8 ;$678 ; Drive 1 or 2, *DRIVENUM EQU $7F8** Corvus parallel interface I/O locations + ioOffset (slot x $10)*ioData equ $C080 ; data from/to driveioStatus equ $C081 ; IO statusioInput equ $C082 ; switch interface to input from driveioOutput equ $C083 ; switch interface to output to drive*romEnable equ $CFFF ; enable firmware at $C800-CFFF** status bits*stDataRdy equ %01000000 ; data is ready to be read** Corvus IMI 5000H controller commands*hdCmdRead equ 2hdCmdWrite equ 3** Monitor ROM Zero Page*CV equ $25 ; Cursor Vertical Displacement** Monitor ROM routines*monVtab equ $FC22 ; Move cursor down 1 lineprintErr equ $FF2D ; Print ERR and beep speakeroldResetV equ $FF59 ; Old reset vector************************************************************************** $C800-$C6FF ROM address space************************************************************************ org $C800 asc  "CORVUS ProDOS/DOS 3.3 ProROM" db chrCR asc  "Copyright 1984-2025 by Patrick Montelo" db chrCR asc  "Build date: " date db chrCR db 0** Initialize card, find card slot, store information* jsr to RTS places $CnXX on stack to capture slot number*initCard equ * php sei tsx inx inx inx lda stack,x plp* Save card slot information and #7 jmp initCommon* For RWTS, do the same, but also set cSlot and slotinitCardD equ * php sei tsx inx inx inx lda stack,x plp* Save card slot information sta cSlot ; rwts only and #7 sta slot ; rwts onlyinitCommon equ * asl a asl a asl a asl a sta ioOffset ; I/O address offset $10 - $70findSlot rts** Get slot 1-7 in A*getSlotA equ * lda ioOffset lsr a lsr a lsr a lsr a rts* Get slot 1-7 in XgetSlotX equ * pha jsr getSlotA tax pla rts* Get slot 1-7 in YgetSlotY equ * pha jsr getSlotA tay pla rts* Get slot $10-70 in X, 1-7 in YgetSlotXY equ * ldx ioOffset pha jsr getSlotA tay pla rts** Save pdBuffer and pdBlock to slot 0 screen holes*savePD equ * pha lda pdBuffer sta pdBufferL lda pdBuffer+1 sta pdBufferH lda pdBlock sta pdBlockL lda pdBlock+1 sta pdBlockH pla rts** Load pdBuffer and pdBlock from slot 0 screen holes*loadPD equ * pha lda pdBufferL sta pdBuffer lda pdBufferH sta pdBuffer+1 lda pdBlockL sta pdBlock lda pdBlockH sta pdBlock+1 pla rts** Load ProROM drive configuration from disk block 0* pdBuffer must point to a valid 256 byte buffer* Carry cleared on success, set on error* Unsafe for write operations since callers buffer is used* call to savePD expected before calling as loadPD* is called on exit*loadCfg equ * jsr beepPro lda #0 sta pdBlock sta pdBlock+1 ldy #1 ; Configuration on drive 1 for both drive 1 and 2 jsr hdRead bcs loadErr ldy #0 jsr getSlotX lda (pdBuffer),y sta blocksD1L,x iny lda (pdBuffer),y sta blocksD1H,x iny lda (pdBuffer),y sta cfgVolsD1,x iny lda (pdBuffer),y sta blocksD2L,x iny lda (pdBuffer),y sta blocksD2H,x iny lda (pdBuffer),y sta cfgVolsD2,x jsr setCfgSum jsr loadPD clcloadErr rts** DOS read config - pdBuffer must be set*dReadCfg equ * jsr savePD jsr loadCfg rts** DOS write config - pdBuffer must be set*dWriteCfg equ * jsr savePD jsr beepPro lda #0 sta pdBlock sta pdBlock+1 ldy #1 ; Configuration on drive 1 for both drive 1 and 2 jsr hdWrite bcs loadErr jsr loadCfg bcs loadErr clc rts** Gets ProDOS X & Y register block count for return to caller* X = block count LSB* Y = block count MSB** On return to block I/O caller, also set:* A = 0 or error code* C = clear or set for error*pdRetXY equ * jsr getCurDrv cpy #2 beq pdRetXYD2pdRetXYD1 equ * ldy blocksD1H,x lda blocksD1L,x jmp pdRetTaxpdRetXYD2 ldy blocksD2H,x lda blocksD2L,xpdRetTax tax dex  ; Subtract 1 for config block cpx #$FF bne pdRetXYex deypdRetXYex equ * rts** Calculate Corvus sector number from ProDOS block number* Adds 1 to pdBlock because $FFFF = config block (0000)* pdBlock multiplied by 2 to convert to sectors* Carry cleared on success, set on error*calcSect equ * inc pdBlock ; Add 1 for config block bne noLsbWrap inc pdBlock+1noLsbWrap equ * jsr getCurDrv cpy #1 bne cBlockD2cBlockD1 lda pdBlock+1 cmp blocksD1H,x bcc pdBlockOk beq cBlockD1L bcs pdBlockOORcBlockD1L lda pdBlock cmp blocksD1L,x beq pdBlockOk bcc pdBlockOk bcs pdBlockOORcBlockD2 lda pdBlock+1 cmp blocksD2H,x bcc pdBlockOk beq cBlockD2L bcs pdBlockOORcBlockD2L lda pdBlock cmp blocksD2L,x bcs pdBlockOOR* pdBlock In Range - multiply x 2 = 256 byte sector numberpdBlockOk equ * asl pdBlock ; Convert blocks to sectors rol pdBlock+1 clc* Requested pdBlock Out Of Range of configured blockspdBlockOOR equ * rts** Advance to next 256 byte sector* Increment pdBlock (sector) number and pdBuffer MSB*nextSect equ * inc pdBlock bne noIncMsb inc pdBlock+1noIncMsb inc pdBuffer+1 rts************************************************************************** ProDOS Block I/O Main Entry Point************************************************************************pdBlockIO2 equ * jsr savePD jsr checkCfg beq haveCfg jsr loadCfg bcs pdErrorhaveCfg equ * lda pdUnitNum ; High bit is drive number 0 or 1 asl a lda #1 adc #0 sta cfgDrive,x ; Drive 1 or 2 lda pdCommand beq pdStatus cmp #pcmdRead beq pdReadBlock cmp #pcmdWrite beq pdWriteBlock cmp #pcmdFormat beq pdFormat** Invalid pdCommand or error in hdRead or hdWrite*pdError equ * jsr loadPD jsr pdRetXY lda #pdIoErr sec rts* Format RequestedpdFormat equ *pdStatus jsr pdRetXY lda #pdSuccess clc rts* Read RequestedpdReadBlock equ * jsr calcSect bcs pdError jsr getCurDrv jsr hdRead bcs pdError jsr nextSect jsr getCurDrv jsr hdRead bcs pdError jsr loadPD jsr pdRetXY lda #pdSuccess clc rts* Write RequestedpdWriteBlock equ * jsr calcSect bcs pdError jsr getCurDrv jsr hdWrite bcs pdError jsr nextSect jsr getCurDrv jsr hdWrite bcs pdError jsr loadPD jsr pdRetXY lda #pdSuccess clc rts************************************************************************** RWTS support routines************************************************************************** get maximum volumes for current drive*getMaxVol equ * jsr getCurDrv cpy #1 bne chkVolD2chkVolD1 equ * lda cfgVolsD1,x jmp setMaxVolchkVolD2 equ * cpy #2 bne rwtsOOR lda cfgVolsD2,xsetMaxVol equ * rts ** get current drive in Y and slot in X*getCurDrv equ * jsr getSlotX ldy cfgDrive,x rts** get total blocks in pdBlock*getTotBlocks equ * jsr getCurDrv cpy #2 beq blocksD2blocksD1 equ * lda blocksD1L,x sta pdBlock lda blocksD1H,x sta pdBlock+1 rtsblocksD2 equ * lda blocksD2L,x sta pdBlock lda blocksD2H,x sta pdBlock+1 rts** find rwts sector for volume, track, sector* adds to the base sector in pdBlock*rwtsSect equ ** get volume number in y ldy #iobLastVol lda (zpIOB),y tay* adjust pdBlock to point to correct sector for drive, volume, track, sector* add 784 sectors for each volume > 1 (volume 0 not stored)nxtVolPos dey beq baseTrack lda pdBlock clc adc #$10 ; Add 784 sectors (49 x 16) for each volume (+$310) sta pdBlock lda pdBlock+1 adc #$3 sta pdBlock+1 jmp nxtVolPos* add 16 sectors for each track > 1 (track 0 not stored)baseTrack ldy #iobTrack lda (zpIOB),y beq noTrack0 ; fix this cmp #dosTracks bcs rwtsOOR taynxtTrkPos dey beq baseSectr lda pdBlock clc adc #dosSects sta pdBlock bcc nxtTrkPos inc pdBlock+1 jmp nxtTrkPos* add the remaining sectorbaseSectr ldy #iobSector lda (zpIOB),y cmp #dosSects bcs rwtsOOR clc adc pdBlock ; adds current sector # in A to pointer sta pdBlock bcc haveSect inc pdBlock+1haveSect equ * ; pdBlock now contains the sector number that will be read or written rts** RWTS called for track 0 which is not stored* Do nothing*noTrack0 equ ** TODO: fill buffer with zeros on read? pla ; pop return address pla jmp dosSuccess** RWTS parameter Out Of Range*rwtsOOR equ * pla ; pop rwts routine return address pla ldy #iobStatus lda #sDriveErr sta (zpIOB),y sec rts************************************************************************** DOS 3.3 RWTS Main Entry Point************************************************************************rwts2 equ * jsr savePD ; save pdBlock and pdBuffer ldy #iobBuffer lda (zpIOB),y sta pdBuffer iny lda (zpIOB),y sta pdBuffer+1* jsr checkCfg beq haveCfgD* reuse loadCfg to get config for dos jsr loadCfg bcs dosError2haveCfgD equ * ldy #iobSlot lda (zpIOB),y cmp ioOffset beq rwtsHD** If not Corvus controller, fallback to standard RWTS*rwtsStd equ * lda dvRWTS+1 ; $B7B5 for 48K RWTS sta tempPtr lda dvRWTS+2 sta tempPtr+1 ldy #3 ; Get standard 48K RWTS address lda (tempPtr),y ; $BD00 pha iny lda (tempPtr),y sta tempPtr+1 pla clc adc #4 ; Skip past overwritten STY $48, STA $49 sta tempPtr ; tempPtr now points to $BD04 (48K), LDY #2 bcc rwtsNoMsb inc tempPtr+1rwtsNoMsb ldy zpIOB lda zpIOB+1 jmp (tempPtr) ; Execute standard RWTS at $BD04 after the patch** dosError*dosError2 jmp dosError** Volume Out Of Range*dosVolOOR equ * jsr loadPD ldy #iobStatus lda #sVolMismat sta (zpIOB),y sec rts** rwts at Corvus hard drive* rwtsHD equ * ldy #iobLastSlot sta (zpIOB),y ; record this access in last slot* ldy #iobVol lda (zpIOB),y beq useKeyVol ; if requested vol = 0, use keyVol cmp #$FF bne setReqVol ; if requested vol = 1-254 use ituseKeyVol equ * lda keyVol ; if requested vol = 0 or 255, use keybol if it's non zero bne setReqVoluseLastVol equ * ldy #iobLastVol ; Used last volume accessed lda (zpIOB),ysetReqVol equ * sta tempPtr ; save requested volume in tempPtr* get maximum volumes jsr getMaxVol sta tempPtr+1 ; save max volumes in tempPtr+1 cmp #0 beq dosVolOOR ; if no dos volumes configured, error* check requested volume lda tempPtr ; requested volume cmp #0 bne volNon0 lda tempPtr+1 ; when 0 use max volume numbervolNon0 equ * cmp tempPtr+1 ; compare to max volumes bcc volOk ; less than max beq volOk ; equal to max jmp dosVolOOR ; greater than maxvolOk equ * ldy #iobVol ; save the volume we're using in all 3 sta (zpIOB),y ldy #iobLastVol sta (zpIOB),y sta keyVol** load pdBlock with total ProDOS blocks for drive 1 or 2* jsr getTotBlocksconvSect asl pdBlock ; convert blocks to sectors (blocks x 2) rol pdBlock+1* pdBlock is now the base sector for all DOS volumes jsr rwtsSect** proccess rwts command* ldy #iobCommand lda (zpIOB),y cmp #cmdSeek beq dosSeek cmp #cmdRead beq dosRead cmp #cmdWrite beq dosWrite* Format results in drive error, must use ProROM utilities* This was a design decision that could be revisiteddosError equ * jsr loadPD ldy #iobStatus lda #sDriveErr sta (zpIOB),y sec rts* Seek is ignored, returns successdosSeek equ *dosSuccess equ * jsr loadPD ldy #iobStatus lda #sSuccess sta (zpIOB),y clc rts* ReaddosRead equ * jsr hdReadD jmp dosSuccess* WritedosWrite equ * jsr hdWriteD jmp dosSuccess** Writes byte in A out to Corvus parallel interface* expects X = ioOffset*hdByteOut equ * phaoutWait lda ioStatus,x bmi outWait sta ioOutput,x ; send data to drive pla  ; data to send sta ioData,x ; data to send rts** Reads a byte in from Corvus parallel interface* expects X = ioOffset*hdByteIn equ * sta ioInput,x ; get data from driveinWait lda ioStatus,x bmi inWait ; wait for data to be ready lda ioData,x ; read data rts** Wait for IMI 5000H controller to process command and get status* expects X = ioOffset*hdWaitStatus equ * lda ioStatus,x bmi hdWaitStatus and #stDataRdy beq hdWaitStatus jsr hdByteIn* sta status rts** Sends a command out to the IMI 5000H controller* driveNum = drive 1 or 2* block = 256 byte block number on hard drive* A = command* Y = drive 1 or 2* sets X = ioOffset*hdCmdOut equ * ldx ioOffset jsr hdByteOut tya  ; Drive 1 or 2 jsr hdByteOut lda pdBlock ; block LSB jsr hdByteOut lda pdBlock+1 ; block MSB jsr hdByteOut rts** Read 256 byte block* Y = drive 1 or 2* sets X = ioOffset* modifies Y* clears carry on success, sets carry on error*hdRead equ * jsr debugB lda #hdCmdRead jsr hdCmdOut jsr hdWaitStatus bmi hdCmdErr* read 256 byte block ldy #0readLoop lda ioStatus,x bmi readLoop lda ioData,x sta (pdBuffer),y iny bne readLoop clc rts** Write 256 byte block specified in block* Y = drive 1 or 2* sets X = ioOffset* modifies Y* clears carry on success, sets carry on error*hdWrite equ * jsr debugB lda #hdCmdWrite   jsr hdCmdOut* write 256 byte block ldy #0writeLoop lda ioStatus,x bmi writeLoop lda (pdBuffer),y sta ioData,x iny bne writeLoop jsr hdWaitStatus bmi hdCmdErr clc rts** Controller error processing command* A/status = error*hdCmdErr sec jsr getSlotX rts** DOS Read*hdReadD equ * jsr debugD jsr getCurDrv jsr hdRead bcs hdError rts*hdError pla pla jmp dosError** DOS Write*hdWriteD equ * jsr debugD jsr getCurDrv jsr hdWrite bcs hdError rts** Calculate configuration check sum*calcChkSum equ * jsr getSlotX lda blocksD1L,x eor blocksD1H,x eor blocksD2L,x eor blocksD2H,x eor cfgVolsD1,x eor cfgVolsD2,x eor #cfgMask rts** Check configuration in screen holes* BEQ config okay, BNE config needs reload*checkCfg equ * jsr calcChkSum cmp cfgChkSum,x rts** Set configuration check sum*setCfgSum equ * jsr calcChkSum sta cfgChkSum,x rts** beep speaker, X pitch, Y duration*beepPro equ * ldx #$FF ldy #$8beep equ * sta $C030 txa phadelay dex bne delay pla tax dey bne beep rts** Is debug enabled?*isDebug equ * lda stack ; look for magic sequence 7269 in bottom of stack cmp #7 bne exitD lda stack+1 cmp #2 bne exitD lda stack+2 cmp #6 bne exitD lda stack+3 cmp #9 bne exitDexitD rts** debug computed block number*debugB equ * jsr isDebug bne exitD* debug is on if 7269 found at $100* this is a way to confirm the correct block is being calculated lda pdBlock ; record corvus sector number sta stack+4 lda pdBlock+1 sta stack+5 rts** debug computed sector number*debugD equ * jsr isDebug bne exitD* debug is on if 7269 found at $100* this is a way to confirm the correct sector is being calculated tya pha ldy #iobLastVol lda (zpIOB),y sta stack+6 ldy #iobTrack lda (zpIOB),y sta stack+7 ldy #iobSector lda (zpIOB),y sta stack+8 pla tay rts************************************************************************* 256 byte bootstrap code $CF00-CFFF appears at $CnXX n = slot 1-7************************************************************************ ds $CF00-*bootstrap ldx #$20 ldx #$0 ldx #$3 ldx #$3C sta romEnable jsr initCard ; set ioOffset sta pdUnitNum ; bit 7 drive 0/1 + slot x $10 taxwaitReady equ * lda #$FF sta ioData,x ldy #0waitRdy1 equ * dey bne waitRdy1 lda ioStatus,x and #stDataRdy beq waitReadywaitRdy2 equ * lda ioStatus,x bmi waitRdy2 lda ioData,x cmp #$8F bne waitReady** Drive ready* Read boot block 0 into $800-$9FF* lda #8 sta pdBuffer+1 lda #0 sta pdBuffer sta pdBlock sta pdBlock+1 lda #pcmdRead sta pdCommand jsr pdBlockIO2 bcs bootErr ldx ioOffset jmp $801** Error during boot, beep speaker and reset* Apple controller jumps to $FABA instead*bootErr lda #23 sta CV jsr monVtab jsr printErr jmp oldResetV** DOS 3.3 RWTS $BD00 Entry Point* ds $CF7F-*rwts equ * sty zpIOB sta zpIOB+1 sta romEnable jsr initCardD jmp rwts2** ProDOS Block I/O Entry Point*pdBlockIO equ * sta romEnable jsr initCard jmp pdBlockIO2** CPD Call vectors* ds $CFB0-*vLoadCfg sta romEnable jmp dReadCfgvSaveCfg sta romEnable jmp dWriteCfg** Corvus caretaker #savethecorvus*caretaker asc  "Jonathan Adar"** Fill with zeros until Corvus RWTS compatability location* ds $CFCF-*corvusRwts equ * ; For compatibility with Corvus Software clc bcc RWTS** Card Signature used to find card by utilities* ds $CFD8-*cardSig asc  "Corvus ProROM by Patrick Montelo"sigEnd db 0** Fill with zeros until special locations $CnFC-CnFF* ds $CFFC-*totBlocks dw $0000 ; Must use status request to get totalstatusByt db %01011111 ; See ProDOS tech ref 6.3.1 db >pdBlockIO