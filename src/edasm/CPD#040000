 sbtl  "CPD Utilities by Patrick Montelo"*********************                  **  PRODOS DOS 3.3  **    CORVUS ROM    **    UTILITIES-    **                  **  COPYRIGHT 1984  **  BY PAT MONTELO  **                  ********************* msb off** Zero page usage*config equ 0 ; 0-5 ProROM configuration block structureblocksD1 equ 0 ; 0-1volsD1 equ 2blocksD2 equ 3 ; 3-4volsD2 equ 5*drive equ 24 ; $18volume equ 25 ; $19iobPtr equ 26 ; $1A-1BromPtr equ 28 ; $1C-$1DtempY equ 30 ; $1EretStatus equ 31 ; $1F Return status to basic** equates*dosTracks equ 50dosSects equ 16catalogT equ $11catalogS equ $Fstack equ $100jmpRwts equ $3D9getIob equ $3E3loadAddr equ $9000 ; HIMEM: 36864keyvol equ $AA66rwtsPatch equ $BD00iob equ $B7E8 ; $3E3 LDY #$E8, LDA #$B7** DOS 3.3 iob data structure* dsect org $0iobType db 0iobSlot db 0iobDrive db 0iobVol db 0iobTrack db 0iobSector db 0iobDCT dw $0000iobBuffer dw $0000iobUnused db 0iobPart db 0iobCommand db 0iobStatus db 0iobLastVol db 0iobLastSlot db 0iobLastDrive db 0 dend** IOB commands*cmdSeek equ 0cmdRead equ 1cmdWrite equ 2cmdFormat equ 3** ProDOS commands*pcmdStatus equ $0pcmdRead equ $1pcmdWrite equ $2pcmdFormat equ $3** ProDOS ROM code calling conventions (Tech Ref 6.3.1)* Call Parameters (6.3.2)*pdCommand equ $42pdUnitNum equ $43pdBuffer equ $44pdBlock equ $46** ProROM screen holes - slot 0 usage*slot equ $4F8 ; slot 1-7ioOffset equ $5F8 ; Card slot IO offset = slot x $10*prErr equ $FF2DoldReset equ $FF59** ProROM calling vector offsets*vLoadCfg equ $B0vSaveCfg equ vLoadCfg+6 ; $B6** Entry point* org loadAddr jmp start** CPD Calling vectors*readCfg jmp doReadCfg ; base addresswriteCfg jmp doWriteCfg ; +3initVol jmp doInitVol ; +6** Look for card signature in firmware* Start at slot 7 and search until slot 1*start equ * lda #$D8 ; start of cardSig in ROM sta romPtr lda #$C7 ; slot 7 sta romPtr+1findCard equ * ldy #32 ; length of signaturefindC lda (romPtr),y cmp cardSig,y bne nextSlot dey bpl findC* Found card sig, patch rwts to point to it lda #$4C sta rwtsPatch lda #$7F sta rwtsPatch+1 lda #0 sta rwtsPatch+3 lda romPtr+1 sta rwtsPatch+2* lda romPtr+1 and #7 sta slot asl a asl a asl a asl a sta ioOffset jmp readCfg*nextSlot equ * dec romPtr+1 lda romPtr+1 cmp #$C0 bne findCard* Couldn't find ProROM jsr prErr jmp oldReset*cardSig asc  "Corvus ProROM by Patrick Montelo"sigEnd db 0** Read configuration block*doReadCfg equ * lda #>ioBuffer sta pdBuffer lda #<ioBuffer sta pdBuffer+1 ldx #vLoadCfg jsr callProROM bcs error* copy 6 byte configuration to $0 ldy #5copyCfg lda ioBuffer,y sta config,y dey bpl copyCfg jmp success** Write configuration block*doWriteCfg equ * lda #>ioBuffer sta pdBuffer lda #<ioBuffer sta pdBuffer+1* Initialize buffer to $FF ldy #$FF tyainitBuf sta ioBuffer,y sta ioBuffer+$100,y dey bne initBuf* copy 6 byte configuration to ioBuffer ldy #5saveCfg lda config,y sta ioBuffer,y dey bpl saveCfg* ldx #vSaveCfg jsr callProROM bcs error jmp success*success lda #$0 sta retStatus clc rts*error equ * ldy #iobStatus lda (iobPtr),y sta retStatus sec rts** Initialize DOS volume*doInitVol equ * jsr setupIob* TODO: write zeros to all tracks and sectors* write catalog sectors $F to $2 ldy #$FwriteCat sty tempY tya  ; sector (a) dey  ; sector-1 (y) sty nextSect ldy #iobSector sta (iobPtr),y lda #catalogT sta nextTrack* jsr callRWTS ; write catalog sector bcs error ldy tempY dey cpy #1 bne writeCat* write last catalog sector  lda #0 sta nextSect sta nextTrack tya  ; 1 ldy #iobSector sta (iobPtr),y jsr callRWTS ; write last catalog sector bcs error* ldy #iobBuffer+1 lda #<VTOC sta (iobPtr),y ; pointing at VTOC buffer* lda #0 ; VTOC sector ldy #iobSector sta (iobPtr),y lda volume sta vtVol jsr callRWTS bcs error jmp success** setup IOB for use*setupIob equ * jsr getIob sty iobPtr sta iobPtr+1* set slot ldy #iobSlot lda ioOffset sta (iobPtr),y* set drive lda drive ; Drive 1 or 2 ldy #iobDrive sta (iobPtr),y lda #catalogT ldy #iobTrack sta (iobPtr),y* set volume lda volume ldy #iobVol sta (iobPtr),y ldy #iobLastVol sta (iobPtr),y sta keyvol* set buffer lda #>sector ldy #iobBuffer sta (iobPtr),y iny lda #<sector sta (iobPtr),y* set command lda #cmdWrite ldy #iobCommand sta (iobPtr),y* set full sector ldy #iobPart lda #0 sta (iobPtr),y rts** Call ProROM RWTS*callRWTS equ * jsr getIob jsr jmpRwts lda #0 sta $48 rts** Call ProROM vector*callProROM equ * stx callVect+1 ldx romPtr+1 stx callVect+2callVect jsr $C000 rts** Align sector image buffer on page base*pageFill equ >* ds $100-pageFill** 256 byte sector image*sector db 0 ; unusednextTrack db catalogTnextSect db 0 ds $FD,$00 ; fill the rest with zeros** VTOC image*VTOC equ * db 4 ; unused but typically 4vtTrack db catalogT ; first catalog trackvtSector db catalogS ; first catalog sectorvtDOSver db 3 ; DOS version dw 0 ; unusedvtVol db 0 ; volume number ds $20,0 ; unusedvtMaxTSp db 122 ; maximum track sector pairs ds $8,0 ; unusedvtLtwsa db $FF ; last track where sectors allocatedvtDira db $FF ; direction of sector allocation dw 0vtTracks db dosTracksvtSects db dosSectsvtBytesPS dw $100 ; bytes per sectorvtBmapT00 db 0,0,0,0vtBmapT01 db $FF,$FF,0,0vtBmapT02 db $FF,$FF,0,0vtBmapT03 db $FF,$FF,0,0vtBmapT04 db $FF,$FF,0,0vtBmapT05 db $FF,$FF,0,0vtBmapT06 db $FF,$FF,0,0vtBmapT07 db $FF,$FF,0,0vtBmapT08 db $FF,$FF,0,0vtBmapT09 db $FF,$FF,0,0vtBmapT10 db $FF,$FF,0,0vtBmapT11 db $FF,$FF,0,0vtBmapT12 db $FF,$FF,0,0vtBmapT13 db $FF,$FF,0,0vtBmapT14 db $FF,$FF,0,0vtBmapT15 db $FF,$FF,0,0vtBmapT16 db $FF,$FF,0,0vtBmapT17 db $0,0,0,0vtBmapT18 db $FF,$FF,0,0vtBmapT19 db $FF,$FF,0,0vtBmapT20 db $FF,$FF,0,0vtBmapT21 db $FF,$FF,0,0vtBmapT22 db $FF,$FF,0,0vtBmapT23 db $FF,$FF,0,0vtBmapT24 db $FF,$FF,0,0vtBmapT25 db $FF,$FF,0,0vtBmapT26 db $FF,$FF,0,0vtBmapT27 db $FF,$FF,0,0vtBmapT28 db $FF,$FF,0,0vtBmapT29 db $FF,$FF,0,0vtBmapT30 db $FF,$FF,0,0vtBmapT31 db $FF,$FF,0,0vtBmapT32 db $FF,$FF,0,0vtBmapT33 db $FF,$FF,0,0vtBmapT34 db $FF,$FF,0,0vtBmapT35 db $FF,$FF,0,0vtBmapT36 db $FF,$FF,0,0vtBmapT37 db $FF,$FF,0,0vtBmapT38 db $FF,$FF,0,0vtBmapT39 db $FF,$FF,0,0vtBmapT40 db $FF,$FF,0,0vtBmapT41 db $FF,$FF,0,0vtBmapT42 db $FF,$FF,0,0vtBmapT43 db $FF,$FF,0,0vtBmapT44 db $FF,$FF,0,0vtBmapT45 db $FF,$FF,0,0vtBmapT46 db $FF,$FF,0,0vtBmapT47 db $FF,$FF,0,0vtBmapT48 db $FF,$FF,0,0vtBmapT49 db $FF,$FF,0,0** IO buffer*ioBuffer equ * ; $9400-95FF