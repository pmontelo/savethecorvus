** Slot independent Corvus Hard Disk Read/Write block subroutines* Copyright Patrick Montelo 1984-2025. All rights reserved.* #savethecorvus** equates*chrCR equ $0DchrA equ $C1chr0 equ $B0column equ $24row equ $25textPtr equ $E0 ; $E0-$E1 used for DCI printescape equ 155 ; escape keykeyPress equ $C000kbdStrobe equ $C010vtab equ $FC22home equ $FC58charOut equ $FDEDprErr equ $FF2D** Corvus parallel interface I/O locations + ioOffset (slot x $10)*ioData equ $C080 ; data from/to driveioStatus equ $C081 ; IO statusioInput equ $C082 ; switch interface to input from driveioOutput equ $C083 ; switch interface to output to drive** status bits*stDataRdy equ %01000000 ; data is ready to be read** Corvus IMI 5000H controller commands*hdCmdRead equ 2hdCmdWrite equ 3** IMI 5012H drive blocks*blocks5012H equ $BE00 ; 48640 256 byte blocks, 0-$BDFF inclusive* org $4000** parameters*status db 0 ; last status from read or writeioOffset db $70 ; slot x $10 ($10-$70)driveNum db 1 ; drive 1 or 2block dw $0000 ; HD block (256 bytes each) number** calling vectors*read jmp hdRead ; read HD blockwrite jmp hdWrite ; write HD blocktestR jmp readTest ; read HD block and show on text screentestRA jmp readAll ; read all blocks and show on text screentestW jmp writeTest ; write HD block and show on text screentestWA jmp writeAll ; write all blocks and show on text screen** Writes byte in A out to Corvus parallel interface* X = ioOffset*hdByteOut equ * phaoutWait lda ioStatus,x bmi outWait sta ioOutput,x ; send data to drive pla  ; data to send sta ioData,x ; data to send rts** Reads a byte in from Corvus parallel interface* X = ioOffset*hdByteIn equ * sta ioInput,x ; get data from driveinWait lda ioStatus,x bmi inWait ; wait for data to be ready lda ioData,x ; read data rts** Wait for IMI 5000H controller to process command and get status* X = ioOffset*hdWaitStatus equ * lda ioStatus,x bmi hdWaitStatus and #stDataRdy beq hdWaitStatus jsr hdByteIn sta status rts** Sends a command out to the IMI 5000H controller* driveNum = drive 1 or 2* block = 256 byte block number on hard drive* A = command* sets X = ioOffset*hdCmdOut equ * ldx ioOffset jsr hdByteOut lda driveNum ; Drive 1 or 2 jsr hdByteOut lda block ; block LSB jsr hdByteOut lda block+1 ; block MSB jsr hdByteOut rts** Read 256 byte block* clears carry on success, sets carry on error*hdRead equ * lda #hdCmdRead jsr hdCmdOut jsr hdWaitStatus bmi hdCmdErr* read 256 byte block ldy #0readLoop lda ioStatus,x bmi readLoop lda ioData,x sta buffer,y iny bne readLoop clc rts** Write 256 byte block specified in block* clears carry on success, sets carry on error*hdWrite equ * lda #hdCmdWrite   jsr hdCmdOut sta ioOutput,x* write 256 byte block ldy #0writeLoop lda ioStatus,x bmi writeLoop lda buffer,y sta ioData,x iny bne writeLoop jsr hdWaitStatus bmi hdCmdErr clc rts** Controller error processing command* A/status = error*hdCmdErr sec rts** read block to text screen memory* clears carry on success, sets carry on error*readTest equ * jsr hdRead bcs exitRT jsr bufToText clcexitRT rts** read all hard drive blocks to text screen*readAll equ * jsr home ; clear screen ldy #7 ldx #0 jsr setOutPos jsr printDci dci  "Reading block:"*  lda #0 sta block sta block+1readAllL equ ** display block number being read in hex ldy #7 ldx #14 jsr setOutPos lda block+1 jsr printHex lda block jsr printHex* read block jsr readTest bcs errorExit lda keypress cmp #escape beq testAbort* next block inc block bne readAllL inc block+1 lda block+1 cmp #<blocks5012H bne readAllL jsr printDci db chrCR dci "Read test complete." rts** IO error durring test*errorExit equ * jsr printDci db chrCR asc "IO error" db chrCR+$80 jsr prErr rts** escape pressed durring test*testAbort equ * sta kbdStrobe jsr printDci db chrCR asc "Test aborted." db chrCR+$80 rts** copy write block to text screen memory then write it* clears carry on success, sets carry on error*writeTest equ * jsr bufToText jsr hdWrite rts** write all hard disk blocks*writeAll equ * jsr home ; clear screen ldy #7 ldx #0 jsr setOutPos jsr printDci dci  "Writing block:"*  lda #0 sta block sta block+1writeAllL equ ** display block number being written in hex ldy #7 ldx #14 jsr setOutPos lda block+1 jsr printHex lda block jsr printHex* store block number MSB in first two bytes of block lda block+1 jsr toHexNibL sta buffer lda block+1 jsr toHexNibR sta buffer+1* store block number LSB in next two bytes of block lda block jsr toHexNibL sta buffer+2 lda block jsr toHexNibR sta buffer+3*  jsr writeTest bcc chkEsc jmp errorExitchkEsc equ * lda keypress cmp #escape bne nxtBlk jmp testAbortnxtBlk equ ** next block inc block bne writeAllL inc block+1 lda block+1 cmp #<blocks5012H bne writeAllL jsr printDci db chrCR dci "Write test complete." rts** Prints a DCI string (high bit on terminated)*printDci equ * lda #0 sta textPtr pla  ; get LSB of return address tay pla  ; get MSB of return address sta textPtr+1dciLoop iny ; increment LSB bne nextChar inc textPtr+1 ; increment MSBnextChar lda (textPtr),y php ora #$80 jsr charOut plp bpl dciLoop ; high bit not set, next character* end of string reached lda textPtr+1 ; push new return address after string pha tya pha rts** Convert A to hex nibble*toHexNibL equ * lsr a lsr a lsr a lsr atoHexNibR equ * and #$0F cmp #10 bcc p0to9 adc #chrA-11 ; A-F rtsp0to9 equ * adc #chr0 ; 0-9 rts** Prints A as HEX*printHex equ * pha jsr toHexNibL jsr charOut pla pha jsr toHexNibR jsr charOut pla rts** copy data buffer to text screen for testing*bufToText equ * ldx #0textOut equ * lda buffer,x sta $400,x ; line 1 lda buffer+40,x sta $480,x ; line 2 lda buffer+80,x sta $500,x ; line 3 lda buffer+120,x sta $580,x ; line 4 lda buffer+160,x sta $600,x ; line 5 lda buffer+200,x sta $680,x ; line 6 lda buffer+240,x cpx #16 bcs line7done sta $700,x ; line 7line7done equ * inx cpx #40 bne textOut rts** set text output position*setOutPos equ * stx column sty row jmp vtab ** Align buffer on 256 byte page*fillPage equ >* ds $100-fillPage** 256 byte disk block buffer*buffer equ * ds 256,0